import { expect, test, describe, beforeEach, afterEach, mock } from 'bun:test'
import jwt from 'jsonwebtoken'
import { signToken,verifyToken } from '../utils/JwtGenerate'

describe('JWT Token Functions - Basic Tests', () => {
  const TEST_EMAIL = 'test@example.com'

  beforeEach(() => {
    if (!process.env.JWT_SECRET) {
      process.env.JWT_SECRET = 'test-secret-key-for-jwt-tokens'
    }
  })

  describe('signToken', () => {
    test('should return a string token', () => {
      const token = signToken(TEST_EMAIL)

      expect(token).toBeString()
      expect(token.length).toBeGreaterThan(10)
    })

    test('should generate different tokens for different emails', () => {
      const token1 = signToken('user1@example.com')
      const token2 = signToken('user2@example.com')

      expect(token1).not.toBe(token2)
      expect(token1).not.toEqual(token2)
    })

    test('should generate valid JWT token structure', () => {
      const token = signToken(TEST_EMAIL)

      // JWT tokens have 3 parts separated by dots
      const parts = token.split('.')
      expect(parts).toHaveLength(3)

      // Each part should be non-empty
      parts.forEach(part => {
        expect(part.length).toBeGreaterThan(0)
      })
    })
  })

  describe('verifyToken', () => {
    test('should verify a token generated by signToken', () => {
      const token = signToken(TEST_EMAIL)
      const verified = verifyToken(token)

      expect(verified).toBeObject()
      expect(verified).toHaveProperty('Email', TEST_EMAIL)
    })

    test('should return payload with correct email', () => {
      const email = 'another@example.com'
      const token = signToken(email)
      const verified = verifyToken(token) as jwt.JwtPayload

      expect(verified.Email).toBe(email)
    })

    test('should throw error for invalid token', () => {
      const invalidToken = 'invalid.token.here'

      expect(() => verifyToken(invalidToken)).toThrow()
    })

    test('should throw error for tampered token', () => {
      const validToken = signToken(TEST_EMAIL)
      const tamperedToken = validToken.slice(0, -5) + 'tempered'

      expect(() => verifyToken(tamperedToken)).toThrow()
    })
  })

  describe('signToken and verifyToken integration', () => {
    test('should work together correctly', () => {
      const email = 'integration@test.com'

      // Sign a token
      const token = signToken(email)
      expect(token).toBeString()

      // Verify the same token
      const payload = verifyToken(token) as jwt.JwtPayload
      expect(payload.Email).toBe(email)
    })

    test('should handle multiple emails correctly', () => {
      const emails = [
        'user1@test.com',
        'user2@test.com',
        'admin@test.com'
      ]

      emails.forEach(email => {
        const token = signToken(email)
        const payload = verifyToken(token) as jwt.JwtPayload

        expect(payload.Email).toBe(email)
      })
    })
  })
})